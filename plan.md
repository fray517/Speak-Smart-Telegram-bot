 # План разработки SpeakSmart (Telegram-бот, MVP)

Основано на требованиях из `project.md`. Цель: получить рабочий MVP
на Python 3.10+ с `aiogram` (polling), режимами **Practice**, **Support**
и **Operator relay**, с логированием и хранением истории в SQLite.

---

## 0) Договорённости и стартовые решения (до начала кодинга)

- **Технологии**: Python 3.10+, `aiogram` v3 + polling, `aiosqlite`.
- **Speech**: реализация через абстракцию `SpeechRecognizer` и выбор
  провайдера из env (`whisper`/`google`), как в `project.md`.
- **Speech (дефолт)**: `whisper`.
- **Аудио-конвертация**: `ffmpeg` с **явным путём** из `FFMPEG_PATH`
  (на Windows не полагаемся на PATH).
- **Хранилище**: SQLite (устойчивее, чем хранение маппинга в памяти).
- **Practice-контент (MVP)**: 20 фраз.
- **UX распознавания**: распознанный текст пользователю **не показываем**
  (только фидбек/подсказка).
- **Оператор**: 1 оператор (один `OPERATOR_ID`/один chat id).
- **Закрытие тикета**: командой оператора (например, `/close <ticket_id>`).

### Результат этапа
- Зафиксированы решения по speech провайдеру, наличию `ffmpeg` и формату
  операторского флоу (один оператор, закрытие командой).

### Критерии готовности
- Дефолтный провайдер распознавания — **`whisper`**.
- `ffmpeg` запускается через **явный путь** из `FFMPEG_PATH`.
- Подготовлен practice-набор из **20 фраз**.
- Операторский флоу рассчитан на **одного оператора** и закрытие тикета
  **командой**.

---

## 1) Каркас проекта и базовая инфраструктура

### Задачи
- **Структура каталогов**: `handlers/`, `services/`, `storage/`, `utils/`,
  `data/`, `assets/`.
- **Точка входа**: `main.py` (запуск polling, регистрация роутеров).
- **Команды**: `/start`, `/help`, `/cancel` (сброс FSM).
- **Конфигурация**: чтение `.env` (пример `.env.example`), валидация
  обязательных переменных.
- **Логирование**: файл `data/logs/app.log` + уровень из `LOG_LEVEL`.
- **Базовая FSM**: состояния для practice/support/operator (как в `project.md`).

### Результат этапа
- Бот запускается локально и отвечает на базовые команды.

### Критерии готовности
- `python main.py` запускает бота без ошибок.
- `/start` и `/help` возвращают ожидаемые тексты.
- `/cancel` сбрасывает состояние в любом режиме.

---

## 2) Хранилище (SQLite) и аудит сообщений

### Задачи
- **Схема БД**: таблицы `users`, `sessions`, `messages`, `tickets`,
  `operator_map` (минимум из `project.md`).
- **Инициализация**: создание БД при старте (или миграция из `migrations.sql`).
- **Репозитории**: запись пользователя, лог входящих/исходящих сообщений,
  создание/обновление тикетов.

### Результат этапа
- В БД сохраняется история и минимум метаданных для диагностики и поддержки.

### Критерии готовности
- После диалога в Telegram в БД появляются записи `users/messages`.
- Ошибки (например, отсутствующий FAQ) логируются в файл.

---

## 3) Voice pipeline (скачивание → конвертация → распознавание)

### Задачи
- **Скачивание voice** из Telegram по `file_id` в temp-директорию.
- **Конвертация** `ogg/opus -> wav` через `ffmpeg` (путь берём из `FFMPEG_PATH`).
- **SpeechRecognizer**:
  - интерфейс `base.py` (единый метод распознавания),
  - `whisper_impl.py` (локально) и/или `google_impl.py` (сетевой вариант),
  - выбор провайдера по `SPEECH_PROVIDER`.
- **Таймауты/ошибки**: корректное сообщение пользователю “Не удалось распознать…”.

### Результат этапа
- На voice вход бот умеет вернуть распознанный текст (внутренний сервис).

### Критерии готовности
- На тестовом voice бот стабильно получает распознанный текст.
- На ошибках (битый файл/таймаут) бот не падает и предлагает повтор.

---

## 4) Practice (контент, сравнение, фидбек)

### Задачи
- **Контент**: `assets/practice_sets.json` + файлы фраз в `assets/phrases/...`.
- **Выбор фразы**: выдача voice prompt + инструкция.
- **Сравнение (MVP)**:
  - нормализация текста (`utils/text_norm.py`),
  - keyword scoring по формуле из `project.md`,
  - пороги фидбека (0.8/0.5).
- **UX**: “следующая / повтор / выход” (кнопки или текстовые команды).
- **Логирование**: сохранять эталон, распознанное, score (хотя бы в `messages`).

### Результат этапа
- Полный сценарий Practice “prompt -> ответ voice -> распознавание -> фидбек”.

### Критерии готовности
- `/practice` выдаёт voice prompt.
- Ответ voice даёт фидбек “Правильно/Почти/Повтор” (без показа
  распознанного текста).

---

## 5) Support (FAQ) + эскалация в оператора

### Задачи
- **FAQ**: `data/faq.json` (формат из `project.md`).
- **Поиск**: по keywords/нормализованным токенам (простая эвристика).
- **Диалог**:
  - `/support` переводит в режим ожидания вопроса,
  - если найдено — ответ,
  - если не найдено — предложить “Передать оператору”.
- **Тикеты**: создание `tickets` со статусом `open`.

### Результат этапа
- Пользователь получает ответы из FAQ или уходит в тикет к оператору.

### Критерии готовности
- Вопрос из FAQ получает корректный ответ.
- Вопрос вне FAQ создаёт тикет и инициирует операторский флоу.

---

## 6) Operator relay (ответ через reply)

### Задачи
- **Уведомление операторов** (по `OPERATOR_IDS`) о новом обращении.
- **Пересылка обращения**:
  - отправить оператору текст вопроса + метаданные пользователя,
  - сохранить mapping `forwarded_message_id -> user_id` в `operator_map`.
- **Ответ оператора**:
  - оператор отвечает reply на сообщение бота,
  - бот по `reply_to_message.message_id` находит `user_id` и пересылает текст
    пользователю,
  - логирует обе стороны.
- **Закрытие тикета**: минимум — команда оператора (например `/close <id>`)
  или авто-закрытие по явному действию (решим по UX).

### Результат этапа
- Оператор может отвечать пользователю из своего чата с ботом надёжно.

### Критерии готовности
- Оператор получает обращение и может ответить reply; пользователь получает ответ.
- После закрытия тикета бот корректно выходит из operator-режима у пользователя.

---

## 7) Полировка, качество, документация

### Задачи
- **Обработка краевых кейсов**:
  - голос не в том режиме,
  - текст в practice,
  - несколько параллельных тикетов (как минимум блокировка повторной эскалации).
- **Ручной тест-план**: перенести/уточнить из `project.md` и пройти.
- **README**:
  - установка зависимостей,
  - настройка `.env`,
  - требования к `ffmpeg`,
  - запуск.
- **PEP 8** и структура модулей (handlers не содержат бизнес-логики).

### Результат этапа
- “Демо-готовый” MVP, понятный для запуска другим человеком.

### Критерии готовности (Definition of Done)
- Стабильный polling бот.
- Practice и Support покрывают основные сценарии без падений.
- Operator relay работает через reply.
- Есть README и `.env.example`.

---

## Риски и рекомендации

- **Whisper на Windows**: может быть тяжёлым по зависимостям/скорости.
  Рекомендация: оставить переключаемость провайдера и подготовить fallback.
- **ffmpeg**: частая причина “не работает” из-за PATH.
  Рекомендация: проверка наличия `ffmpeg` при старте и понятная ошибка.
- **Операторский флоу**: надёжнее именно reply-relay (как в `project.md`),
  не пытаться “напрямую” связывать пользователя и оператора.

---

## Уточняющие вопросы (чтобы план был точнее)

- **Speech**: подтверждено — дефолт `whisper`.
- **ffmpeg**: подтверждено — используем **явный путь** через `FFMPEG_PATH`.
- **Контент practice**: подтверждено — стартуем с **20 фраз**.
- **Показ распознанного текста**: подтверждено — **скрываем**.
- **Оператор**: подтверждено — **один**.
- **Закрытие тикета**: подтверждено — достаточно команды.

